"use strict";(self.webpackChunkxml_to_json_webstream_docs=self.webpackChunkxml_to_json_webstream_docs||[]).push([[594],{3478:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>m});var a=n(4848),s=n(8453);const i={},o="xml-to-json-webstream",r={id:"api/index",title:"xml-to-json-webstream",description:"A modern frontend and xml parser library that uses browser's webstreams and the browser compatible sax-ts under the hood, and adds better typings to it and uses an alternative async iteration API instead of an event API.",source:"@site/docs/api/index.md",sourceDirName:"api",slug:"/api/",permalink:"/xml-to-json-webstream/docs/api/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",next:{title:"Function: streamXMLToJSON()",permalink:"/xml-to-json-webstream/docs/api/functions/streamXMLToJSON"}},l={},m=[{value:"Installation",id:"installation",level:2},{value:"npm",id:"npm",level:3},{value:"yarn",id:"yarn",level:3},{value:"Why?",id:"why",level:2},{value:"Documentation",id:"documentation",level:2},{value:"streamXMLToJSON",id:"streamxmltojson",level:2},{value:"Examples defined by Emit Modes:",id:"examples-defined-by-emit-modes",level:3},{value:"&quot;updating-root&quot;",id:"updating-root",level:4},{value:"&quot;updating-named&quot;",id:"updating-named",level:4},{value:"&quot;leafs-named&quot;",id:"leafs-named",level:4},{value:"&quot;leafs&quot;",id:"leafs",level:4},{value:"streamingSAX",id:"streamingsax",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"xml-to-json-webstream",children:"xml-to-json-webstream"})}),"\n",(0,a.jsx)("p",{align:"center",children:(0,a.jsx)("img",{width:"280",src:"https://raw.githubusercontent.com/johnsonjo4531/xml-to-json-webstream/refs/heads/main/assets/logo.svg"})}),"\n",(0,a.jsx)(t.p,{children:"A modern frontend and xml parser library that uses browser's webstreams and the browser compatible sax-ts under the hood, and adds better typings to it and uses an alternative async iteration API instead of an event API."}),"\n",(0,a.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(t.p,{children:"Pick your method of installation"}),"\n",(0,a.jsx)(t.h3,{id:"npm",children:"npm"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"npm i xml-to-json-webstream\n"})}),"\n",(0,a.jsx)(t.h3,{id:"yarn",children:"yarn"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"yarn add xml-to-json-webstream\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["\u2139\ufe0f This library is React Native compatible, but until fetch in React Native supports streaming content and web streams ",(0,a.jsx)(t.a,{href:"https://github.com/facebook/react-native/issues/27741#issuecomment-2362901032V",children:"you must setup fetch here to stream content"})," that link also sets up webstreaming library polyfills which is necessary for this library to work in React Native.)"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"why",children:"Why?"}),"\n",(0,a.jsx)(t.p,{children:"Because I had some massive RSS feeds to parse and I needed a way to parse only parts of the RSS data as json that I needed at the time. I also wanted a way to query only part of an RSS feed I would need efficiently. I couldn't find a good library that should work for my use case of React-native (my actual use case and what has been tested), Node (this hasn't been tested but should either just work depending on Node versions or need polyfills), and Web (which should just work since we are using webstreams) so I thought I'd create one."}),"\n",(0,a.jsx)(t.h2,{id:"documentation",children:"Documentation"}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"https://johnsonjo4531.github.io/xml-to-json-webstream",children:"docs"})]}),"\n",(0,a.jsx)(t.h2,{id:"streamxmltojson",children:"streamXMLToJSON"}),"\n",(0,a.jsx)(t.p,{children:"This function streams XML in various ways into JSON"}),"\n",(0,a.jsx)(t.p,{children:"One thing to note before looking at the example is that there are multiple options for emitting data to json from xml in this library."}),"\n",(0,a.jsx)(t.p,{children:"Here's their explanation:"}),"\n",(0,a.jsx)(t.h3,{id:"examples-defined-by-emit-modes",children:"Examples defined by Emit Modes:"}),"\n",(0,a.jsx)(t.p,{children:"The various emit modes defined. Note that each example is different in that\nit showcases a specific emit option or mode that is sent into the options object\nin the second argument to the streamXMLToJSON function. Each emit option only happens when a closing or selfclosing xml tag is hit but depending on the emit mode it may be the closing tag of a subelement."}),"\n",(0,a.jsx)(t.h4,{id:"updating-root",children:'"updating-root"'}),"\n",(0,a.jsx)(t.p,{children:"Emits the root xml element as json over and over slowly adding new items and ubitems to it as they are parsed."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n\nasync function getTitle(stream: ReadableStream<Uint8Array | string>) {\n    for await (\n        const item of streamXMLToJSON(stream, {\n            emit: "updating-root",\n        })\n    ) {\n        if (item?.rss?.channel?.title) {\n            return item?.rss?.channel?.title;\n        }\n    }\n    return "";\n}\nconst stream = await getExampleData(0);\n\nconsole.log(await getTitle(stream));\n'})}),"\n",(0,a.jsx)(t.h4,{id:"updating-named",children:'"updating-named"'}),"\n",(0,a.jsx)(t.p,{children:'Alot like "updating-root" except you give it a specific name or path of the only items you want emitted.\nNote that the path syntax does not care where the first element of the path exists in the xml\nit will also treat all arrays as if their items were just objects and emit only those that match.'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n// Get just enough data about the channel and then output.\nasync function getChannel(\n    stream: ReadableStream<string | Uint8Array>,\n) {\n    // In rss entries are generally small so we can\n    for await (\n        const { channel } of streamXMLToJSON(stream, {\n            emit: "updating-named",\n            name: "channel",\n        })\n    ) {\n        console.log(channel, channel.image);\n        if (\n            channel.title &&\n            channel.image\n        ) {\n            return channel;\n        }\n    }\n}\nconst stream = await getExampleData(0);\nconsole.log(await getChannel(stream));\n'})}),"\n",(0,a.jsx)(t.h4,{id:"leafs-named",children:'"leafs-named"'}),"\n",(0,a.jsx)(t.p,{children:'Alot like "leafs", but uses the name option to emit only leaf nodes that either match an exact name or a path that will lead to that name.\nNote that the path syntax does not care where the first element of the path exists in the xml\nit will also treat all arrays as if their items were just objects and emit only those that match.'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n\nasync function* getChannelImage(\n    stream: ReadableStream<string | Uint8Array>,\n) {\n    for await (\n        const { image, ["itunes:image"]: itunesImage } of streamXMLToJSON<\n            {\n                image?: {\n                    link?: string;\n                    url?: string;\n                    title?: string;\n                    description?: string;\n                };\n                ["itunes:image"]?: { "@href"?: string };\n            }\n        >(\n            stream,\n            {\n                emit: "leafs-named",\n                // Get the channel\'s image or itunes:image\n                name: ["channel.image", "channel.itunes:image"],\n            },\n        )\n    ) {\n        yield { image, itunesImage } as const;\n    }\n}\nconst stream = await getExampleData(0);\nfor await (const item of getChannelImage(stream)) {\n    console.log(item.image ?? item.itunesImage);\n}\n'})}),"\n",(0,a.jsx)(t.h4,{id:"leafs",children:'"leafs"'}),"\n",(0,a.jsx)(t.p,{children:"The most verbose of all options and probably not what you want, but get's any and all combinations of parts and pieces of json possible using breadth first search.\nBasically walks the whole XML tree and emits JSON as it goes."}),"\n",(0,a.jsx)(t.h2,{id:"streamingsax",children:"streamingSAX"}),"\n",(0,a.jsx)(t.p,{children:"This is a streaming xml parser that uses a port of the sax parser from isaacs it is what streamXMLToJSON uses under the hood to write it's streaming xml parser. Here's a simple example that only gets the text events of the sax parser. There are many more event types that can be seen in the documentation."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'const stream = await getExampleData(3);\nlet text = "";\nfor await (\n    const item of stream.pipeThrough(streamingSAX({\n    saxOptions: {\n        strict: true,\n    },\n    events: ["text"],\n}))\n) {\n    text += item.payload;\n}\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(6540);const s={},i=a.createContext(s);function o(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);