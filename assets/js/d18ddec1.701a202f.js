"use strict";(self.webpackChunkxml_to_json_webstream_docs=self.webpackChunkxml_to_json_webstream_docs||[]).push([[3315],{9730:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=t(4848),s=t(8453);const i={},r="Function: streamXMLToJSON()",o={id:"api/functions/streamXMLToJSON",title:"Function: streamXMLToJSON()",description:"streamXMLToJSON\\(stream, opts): AsyncGenerator\\",source:"@site/docs/api/functions/streamXMLToJSON.md",sourceDirName:"api/functions",slug:"/api/functions/streamXMLToJSON",permalink:"/xml-to-json-webstream/docs/api/functions/streamXMLToJSON",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"xml-to-json-webstream",permalink:"/xml-to-json-webstream/docs/api/"},next:{title:"Function: streamingSAX()",permalink:"/xml-to-json-webstream/docs/api/functions/streamingSAX"}},l={},d=[{value:"Type Parameters",id:"type-parameters",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Returns",id:"returns",level:2},{value:"Tutorial",id:"tutorial",level:2},{value:"Emit Modes:",id:"emit-modes",level:2},{value:"&quot;updating-root&quot;",id:"updating-root",level:3},{value:"Examples",id:"examples",level:2},{value:"Tutorial",id:"tutorial-1",level:2},{value:"&quot;updating-named&quot;",id:"updating-named",level:3},{value:"Tutorial",id:"tutorial-2",level:2},{value:"&quot;leafs-named&quot;",id:"leafs-named",level:3},{value:"Tutorial",id:"tutorial-3",level:2},{value:"&quot;leafs&quot;",id:"leafs",level:3},{value:"Defined in",id:"defined-in",level:2}];function m(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"function-streamxmltojson",children:"Function: streamXMLToJSON()"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"streamXMLToJSON"}),"<",(0,a.jsx)(n.code,{children:"T"}),">(",(0,a.jsx)(n.code,{children:"stream"}),", ",(0,a.jsx)(n.code,{children:"opts"}),"): ",(0,a.jsx)(n.code,{children:"AsyncGenerator"}),"<",(0,a.jsx)(n.code,{children:"T"}),">"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,a.jsxs)(n.p,{children:["\u2022 ",(0,a.jsx)(n.strong,{children:"T"})," ",(0,a.jsx)(n.em,{children:"extends"})," ",(0,a.jsx)(n.a,{href:"/xml-to-json-webstream/docs/api/type-aliases/JSONStates",children:(0,a.jsx)(n.code,{children:"JSONStates"})})," = ",(0,a.jsx)(n.code,{children:"Record"}),"<",(0,a.jsx)(n.code,{children:"string"}),", ",(0,a.jsx)(n.code,{children:"any"}),">"]}),"\n",(0,a.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(n.p,{children:["\u2022 ",(0,a.jsx)(n.strong,{children:"stream"}),": ",(0,a.jsx)(n.code,{children:"ReadableStream"}),"<",(0,a.jsx)(n.code,{children:"string"})," | ",(0,a.jsx)(n.code,{children:"Uint8Array"}),">"]}),"\n",(0,a.jsx)(n.p,{children:"A ReadableStream of xml in string or Uint8Array format."}),"\n",(0,a.jsxs)(n.p,{children:["\u2022 ",(0,a.jsx)(n.strong,{children:"opts"}),": ",(0,a.jsx)(n.code,{children:"object"})," | ",(0,a.jsx)(n.code,{children:"object"})," = ",(0,a.jsx)(n.code,{children:"{}"})]}),"\n",(0,a.jsx)(n.p,{children:"The following are the properties of opts."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"emit"}),' - decides which emit strategy to take. a string of value "leafs", "updating-root", "leafs-named", or "updating-named"..']}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"name"}),' - names to filter our XML by. only matters if emit is either "named-leaf" or "updated-named". It\'s value is either a string or string[].']}),"\n",(0,a.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"AsyncGenerator"}),"<",(0,a.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,a.jsx)(n.h2,{id:"tutorial",children:"Tutorial"}),"\n",(0,a.jsx)(n.h2,{id:"emit-modes",children:"Emit Modes:"}),"\n",(0,a.jsx)(n.p,{children:"The various emit modes defined. Each emit only happens when a closing xml tag is hit but\ndepending on the emit mode it may be the closing tag of a subelement."}),"\n",(0,a.jsx)(n.h3,{id:"updating-root",children:'"updating-root"'}),"\n",(0,a.jsx)(n.p,{children:"Emits the root xml element as json over and over slowly adding new items and subitems to it as they are parsed."}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n\nasync function getTitle(stream: ReadableStream<Uint8Array | string>) {\n    for await (\n        const item of streamXMLToJSON(stream, {\n            emit: "updating-root",\n        })\n    ) {\n        if (item?.rss?.channel?.title) {\n            return item?.rss?.channel?.title;\n        }\n    }\n    return "";\n}\nconst stream = await getExampleData(0);\n\nconsole.log(await getTitle(stream));\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n// Get just enough data about the channel and then output.\nasync function getChannel(\n    stream: ReadableStream<string | Uint8Array>,\n) {\n    // In rss entries are generally small so we can\n    for await (\n        const { channel } of streamXMLToJSON(stream, {\n            emit: "updating-named",\n            name: "channel",\n        })\n    ) {\n        console.log(channel, channel.image);\n        if (\n            channel.title &&\n            channel.image\n        ) {\n            return channel;\n        }\n    }\n}\nconst stream = await getExampleData(0);\nconsole.log(await getChannel(stream));\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n\nasync function* getChannelImage(\n    stream: ReadableStream<string | Uint8Array>,\n) {\n    for await (\n        const { image, ["itunes:image"]: itunesImage } of streamXMLToJSON<\n            {\n                image?: {\n                    link?: string;\n                    url?: string;\n                    title?: string;\n                    description?: string;\n                };\n                ["itunes:image"]?: { "@href"?: string };\n            }\n        >(\n            stream,\n            {\n                emit: "leafs-named",\n                // Get the channel\'s image or itunes:image\n                name: ["channel.image", "channel.itunes:image"],\n            },\n        )\n    ) {\n        yield { image, itunesImage } as const;\n    }\n}\nconst stream = await getExampleData(0);\nfor await (const item of getChannelImage(stream)) {\n    console.log(item.image ?? item.itunesImage);\n}\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { streamXMLToJSON } from "../../index.ts";\nimport { getExampleData } from "../utils.ts";\n\nasync function getRSSTitle(stream: ReadableStream<Uint8Array | string>) {\n   for await (\n       const item of streamXMLToJSON(stream, {\n           emit: "updating-root",\n       })\n   ) {\n       if (item?.rss?.channel?.title) {\n           return item?.rss?.channel?.title;\n       }\n   }\n   return "";\n}\nconst stream = await getExampleData(0);\nconsole.log(await getTitle(stream));\n'})}),"\n",(0,a.jsx)(n.h2,{id:"tutorial-1",children:"Tutorial"}),"\n",(0,a.jsx)(n.h3,{id:"updating-named",children:'"updating-named"'}),"\n",(0,a.jsx)(n.p,{children:'Alot like "updating-root" except you give it a specific name or path of the only items you want emitted.\nNote that the path syntax does not care where the first element of the path exists in the xml\nit will also treat all arrays as if their items were just objects and emit only those that match.'}),"\n",(0,a.jsx)(n.h2,{id:"tutorial-2",children:"Tutorial"}),"\n",(0,a.jsx)(n.h3,{id:"leafs-named",children:'"leafs-named"'}),"\n",(0,a.jsx)(n.p,{children:'Alot like "leafs", but uses the name option to emit only leaf nodes that either match an exact name or a path that will lead to that name.\nNote that the path syntax does not care where the first element of the path exists in the xml\nit will also treat all arrays as if their items were just objects and emit only those that match.'}),"\n",(0,a.jsx)(n.h2,{id:"tutorial-3",children:"Tutorial"}),"\n",(0,a.jsx)(n.h3,{id:"leafs",children:'"leafs"'}),"\n",(0,a.jsx)(n.p,{children:"The most verbose of all options and probably not what you want, but get's any and all combinations of parts and pieces of json possible using breadth first search.\nBasically walks the whole XML tree and emits JSON as it goes."}),"\n",(0,a.jsx)(n.h2,{id:"defined-in",children:"Defined in"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/johnsonjo4531/xml-to-json-webstream/blob/4a6d5ede6d5de55bf286a795f124a9d92e4f5239/src/index.ts#L517",children:"index.ts:517"})})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);